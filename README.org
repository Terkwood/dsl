#+TITLE: The future home of the L4 DSL

This specification is in EARLY DRAFT stage right now, and is expected to evolve throughout the remainder of 2020. The only people writing L4 according to this spec are the core development team, and even then it's not expected to work.

* Draft Language Specification v0.3.0

We want to be able to translate natural-language contracts and laws to code, without loss of meaning; so our language needs to be as expressive as natural language "pseudocode", while remaining formal and well-defined.

** Quickstart: L4 By Example

*** Hello, Cabbage

Suppose cabbages may be sold only on the day a full moon occurs -- unless an exemption was granted by the Director of Agriculture. Buyers have the right, within three weeks of purchase, to return their cabbages for a 90% refund, which the seller must issue within 3 days of the return.

Let's say it in L4:

#+begin_src sql :noweb-ref l4-rules
  RULE   1 SaleRestricted
           :en:"The Sale of Cabbages is Restricted."
           :se:"Försäljning av kål är begränsad."
    PARTY NOBODY      AS P1
      MAY sell Item   AS sale
     WHEN Item IS cabbage
   UNLESS sale IS onLegalDate
       OR UNLIKELY P1 HAS Exemption.from ~ [DirectorOfAgriculture]
    HENCE ReturnPolicy
    WHERE sale IS onLegalDate
            WHEN sale.date ~ LegalDates
            WHERE LegalDates = external(url="https://www.almanac.com/astronomy/moon/full/")

  RULE  2 ReturnPolicy
    GIVEN sale
    PARTY Buyer
      MAY return Item
   BEFORE sale.date + 3 weeks
    HENCE Net3

  RULE  3 Net3
    GIVEN return
    PARTY Seller
     MUST refund Amount
   BEFORE return.date + 3 days
    WHERE Amount = $return.sale.cash * 90%

  RULE  4 Cabbage
     DEEM Item IS cabbage
     WHEN Item.species ~ ["Brassica chinensis" | "Brassica oleracea"]
#+end_src

We picked this example because it embeds a simple mini-contract in the sale-and-return part.

The rest of this document explains the syntax and shows the BNF language definition.

Our ontology:
- ~x ISA Y~ :: x is an instance; Y is a class.
- ~Y ISA Z~ :: Y is a class; Z is a superclass.

*** Rule Headers

A "RULE" stanza is labeled with a numeric identifier, a name, or both, followed by zero or more language strings.

#+begin_src bnfc :noweb-ref l4bnfc
  Rule.      Rule      ::= "RULE" RuleDef RuleName RuleBody;

  RID.       RuleDef   ::=         ObjAttr ;
  RNumID.    RuleDef   ::= Integer ObjAttr ;
  RNum.      RuleDef   ::= Integer ;
  RName.     RuleName  ::= OptLangStrings ;

  rules      OptLangStrings ::= | LangStrings;

#+end_src

*** Rule Bodies

Every rule is one of the following types:

**** NOOP

A rule body that does nothing. This is just for dev testing. By convention this rule is always considered satisfied when evaluated -- it is vacuously true.

#+begin_src bnfc :noweb-ref l4bnfc
  RBNoop.    RuleBody  ::= "NOOP";
#+end_src

**** DEEM

A constitutive rule with several limbs. Thing A can be deemed to be a Thing B under conditions C.

#+begin_src bnfc :noweb-ref l4bnfc
  RuleDeem.   RuleBody  ::= GivenLimb "DEEM" [Constraint] WithLimb WhenLimb WhereLimb;
#+end_src

- given :: context parameters, analogous to function arguments
- constraint :: one or more subjects of the deem: that an A counts as B in some way, or has some value, or some inequality
- with :: attributes of the subject(s)
- when :: pre-conditions for the deem to operate
- where :: subsidiary definitions

Deem rules are a good place to shoehorn your function definitions.

More about these limbs below.

**** Modal

A rule that defines a node in the obligation graph. These express what Ken Adams calls

- language of performance
- language of obligation
- language of discretion
- language of prohibition

In short,
- given some context (usually one or more references to ancestors to that node)
- when some set of conditions holds (see also Coode on Legislative Expression)
- some party
- must, may, or shan't
- perform some action (satisfying some set of parameters)
- by some deadline

And if they perform as specified, the state graph proceeds to the node specified in the "hence" limb.

If they fail to perform, the state graph proceeds to the node specified in the "lest" limb.

#+begin_src bnfc :noweb-ref l4bnfc
  RModal.  RuleBody    ::= GivenLimb PartyLimb DeonticLimb WhenLimb DeadlineLimb HenceLimb WhereLimb ;
  rules    PartyLimb   ::= "PARTY" PartyDef AsAlias;
  PSome.   PartyDef    ::= ObjAttr ;
  PEvery.  PartyDef    ::= PEvery ;
  rules    PEvery      ::= "EVERYBODY" | "ANYBODY" | "EVERYONE" | "ANYONE" ;
  PNobody. PartyDef    ::= PNobody;
  rules    PNobody     ::= "NOBODY" | "NO-ONE" | "NOONE" | "NONE" ;
  rules    AsAlias     ::= | "AS" ObjAttr ;
  rules    DeonticLimb ::= DeonticExpr ActionLimb;
  DEMust.  DeonticExpr ::= "MUST" ;
  DEMay.   DeonticExpr ::= "MAY"  ;
  DEShant. DeonticExpr ::= "SHANT" ;
  rules    ActionLimb  ::= ObjMethod [Blah] AsAlias ;
  rules    DeadlineLimb ::= | "BEFORE" TemporalExpr AsAlias ;
#+end_src

See [[https://drive.google.com/file/d/1sLmVMZqHhQDzj8dikKt-8CNemF-nGCn1/view?usp=sharing][page 41 of Hvitved's PhD Thesis]].

As-aliases provide variable bindings to elements of the rule. In Haskell they are like the "@" in a pattern match.

We need to beef up the temporal expressions, but for now they are:

#+begin_src bnfc :noweb-ref l4bnfc
  rules    TemporalExpr ::= DateTime DurationExpr | ObjAttr DurationExpr 
                          | "EARLIEST" JunctionList
                          | "LATEST"   JunctionList;
  rules    DurationExpr ::= | "+" Duration ;
  TDYM.    Duration     ::= Integer "years" ;
  TDW.     Duration     ::= Integer "weeks" ;
  TDD.     Duration     ::= Integer "days" ;
  TDDH.    Duration     ::= Integer "days" "and" Integer "hours" ;
  DNoHence. HenceLimb    ::= ;
  DHence.   HenceLimb    ::= "HENCE" Goto Args OptLangStrings;
  DHeLe.    HenceLimb    ::= "HENCE" Goto Args OptLangStrings "LEST" Goto Args OptLangStrings ;
  DLest.    HenceLimb    ::=                                  "LEST" Goto Args OptLangStrings ;
  rules     Goto         ::= RuleDef | "FULFILLED" | "BREACH" ;
#+end_src

The optional langstrings provide hints to the interpreter and to downstream components.

**** Assertion

A rule that describes, using LTL/CTL, certain properties of the obligation graph.

Violations of these properties can be found by a model checker.

The syntax for assertion rules has not yet been defined.

**** Meta-rule

A rule that establishes priority when other rules conflict.

The syntax for meta-rules has not yet been defined. In contracts and laws we see the idea of "notwithstanding" and "subject to".

**** Debug

The "MATCHTYPE" rule body is for debugging purposes only.

#+begin_src bnfc :noweb-ref l4bnfc
  rules   RuleBody  ::= "MATCHTYPE" "{" [MatchVars] "}";
  rules   MatchVars ::= "MathExpr"    MathExpr
                      | "MatchExpr"   MatchExpr
                      | "RelBool"     RelBool
                      | "VarExpr"     VarExpr
                      | "Constraint"  Constraint
                      | "Numberlike"  Numberlike
                      | "BoolExp"     BoolExp
                      | "ObjMethod"   ObjMethod
                      | "ObjAttr"     ObjAttr
                      | "ObjAttrElem" ObjAttrElem
                      | "UnifyExpr"   UnifyExpr
                      | "UnifyElem"   [UnifyElem]
                      | "WhenLimb"    WhenLimb
                      | "WhereLimb"   WhereLimb
                      | "DeonticLimb" DeonticLimb
                      | "BraceList"   BraceList
                      | "ArrayOfBraces"   ArrayOfBraces
                      | "HenceLimb"   HenceLimb;
  separator nonempty MatchVars ";";
#+end_src



*** Entities

*** Pragmas

*** Modules

*** Imports

*** Formal Verification using Temporal Logics

*** Transpilation and Extraction to Operational Languages

*** Natural Language Generation

** Reference Manual and BNFC specification

*** Projects

An L4 Project contains one or more modules.

*** Modules and Structure

Modules offer namespaces. The import and export syntax borrows from Haskell.

An L4 Module is a file.

The /default name/ of the module is derived from its import statement, minus any ~.l4*~ extension.

The following import statements result in the following default module names:

| import                                          | default name |
|-------------------------------------------------+--------------|
| ~import "Foo/Bar/Baz.l4"~                       | Foo.Bar.Baz  |
| ~import "/usr/local/share/L4/./Foo/Bar/Baz.l4"~ | Foo.Bar.Baz  |
| ~import "test/./Foo/Bar/Baz.l4"~                | Foo.Bar.Baz  |

The default name is made by 
- deleting any prefix matching the regex ~^.*/\.+/~
- deleting any suffix matching the suffix ~\.l4\w*$~
- converting any directory separators to dots

A module can explicitly give itself a name by saying

#+begin_src haskell :noweb-ref l4-example1
  module Foo.Bar.Baz where
#+end_src

#+begin_src bnfc :noweb-ref l4bnfc
  ModuleDecl. Module ::= "module" ObjAttr "where";
#+end_src

An L4 Module contains a list of directives and statements.

#+begin_src bnfc :noweb-ref l4bnfc
  Toplevel.  Tops      ::= [Toplevels];
  rules      Toplevels ::= Module | Import | Pragma 
                         | Rule | Entity | Scenario ;
  terminator Toplevels ";";

  layout toplevel;
  layout "WITH", "TRACE", "WHERE", "MATCHTYPE", "HAVING" ;
  entrypoints Tops;
#+end_src

C-style and Javascript-style comments are both supported. Also Haskell-style, as a nod to our implementation language.

#+begin_src bnfc :noweb-ref l4bnfc
    comment "//" ;
    comment "--" ;
    comment "/*" "*/" ;
#+end_src

*** Directives
**** module directive is dealt with above

Suppose we have a ContractLaw library:

#+begin_src haskell :noweb yes :tangle bnfc/l4/ContractLaw.l4
  module ContractLaw where
#+end_src

Other modules are welcome to import this module. They would end up with ~elements~ in the namespace, explicitly referenceable as ContractLaw.Rule.1

**** pragma: version

#+begin_src bnfc :noweb-ref l4bnfc
  rules Pragma ::= "pragma" CommaList ;
#+end_src

**** history

previous versions of this ruleset are accessible where? because this ruleset may refer to previous versions.

**** import

#+begin_src haskell :noweb-ref l4-example1
import ContractLaw
#+end_src

#+begin_src bnfc :noweb-ref l4bnfc
  Import. Import ::= "import" ObjAttr ;
#+end_src

**** numbering

A numbering directive instructs the output engine to reset the autonumbering to a specific value.

This is kind of a holdover from the C pre-processor. Do we really need it?

*** Statements

An L4 statement is one of the following:

**** Rule Elements

This section goes into detail about the elements of rule statements:

***** When: Constraint Expressions

Constraint Expressions are used both to evaluate truth values as part of a reasoning operation, and to "assign" values immutably.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      WhenLimb   ::= | "WHEN"   BoolExp UnlessExpr;
  rules      UnlessExpr ::= | "UNLESS" BoolExp;
#+end_src

The When Limb has an optional When part and an optional Unless part.

Here's the truth table for how the parts interact

| When    | Unless  | Result        |
|---------+---------+---------------|
| absent  | -       | true          |
| present | absent  | evaluate when |
| present | present | as below      |

Here's the truth table for how the When/Unless limbs desugar.

| Party     | DeonticExpr | WHEN  | UNLESS | means           | HENCE |
|-----------+-------------+-------+--------+-----------------+-------|
| Some P    | MAY         | true  | true   | -               |       |
| Some P    | MAY         | true  | false  | P MAY           |       |
| Some P    | MAY         | false | true   | -               |       |
| Some P    | MAY         | false | false  | -               |       |
| Some P    | MUST        | true  | true   | -               |       |
| Some P    | MUST        | true  | false  | P MUST          |       |
| Some P    | MUST        | false | true   | -               |       |
| Some P    | MUST        | false | false  | -               |       |
| Some P    | SHANT       | true  | true   | -               |       |
| Some P    | SHANT       | true  | false  | P SHANT         |       |
| Some P    | SHANT       | false | true   | -               |       |
| Some P    | SHANT       | false | false  | -               |       |
| Everybody | MAY         | true  | true   | -               |       |
| Everybody | MAY         | true  | false  | Everybody MAY   |       |
| Everybody | MAY         | false | true   | -               |       |
| Everybody | MAY         | false | false  | -               |       |
| Everybody | MUST        | true  | true   | -               |       |
| Everybody | MUST        | true  | false  | Everybody MUST  |       |
| Everybody | MUST        | false | true   | -               |       |
| Everybody | MUST        | false | false  | -               |       |
| Everybody | SHANT       | true  | true   | P MAY           |       |
| Everybody | SHANT       | true  | false  | Everybody Shant |       |
| Everybody | SHANT       | false | true   | P MAY           |       |
| Everybody | SHANT       | false | false  | -               |       |
| Nobody    | MAY         | true  | true   | P MAY           |       |
| Nobody    | MAY         | true  | false  | Nobody MAY      |       |
| Nobody    | MAY         | false | true   | P MAY           |       |
| Nobody    | MAY         | false | false  | -               |       |
| Nobody    | MUST        | true  | true   | -               |       |
| Nobody    | MUST        | true  | false  | Nobody must     |       |
| Nobody    | MUST        | false | true   | -               |       |
| Nobody    | MUST        | false | false  | -               |       |
| Nobody    | SHANT       | true  | true   | Everybody MAY   |       |
| Nobody    | SHANT       | true  | false  | Nobody SHANT    |       |
| Nobody    | SHANT       | false | true   | P MAY           |       |
| Nobody    | SHANT       | false | false  | -               |       |

***** Constraint Unification

THIS IS STILL UNDER CONSTRUCTION

We define a travel budget for a given month as the number of employees living in certain states multiplied by the one-way plane fare, times 2 (rough approximation to roundtrip fare), when the month is June or September.

Due to cost-cutting measures, there is no travel budget in any other month.

Due to cost-cutting measures, only those lucky employees living in two regions are allowed to travel.

In Haskell we would write something like:

#+begin_src haskell :tangle rando.hs
  newtype Month = M String deriving (Show, Eq)
  type    PlaneFare = Int
  data    Employee = E { state :: State, country :: Country } deriving (Show, Eq)
  newtype StaffDirectory = SD [Employee] deriving (Show, Eq)
  type    State = String
  type    Country = String

  travelBudget :: Month -> PlaneFare -> StaffDirectory -> [State] -> Int
  travelBudget month fare staffdir luckyStates
    | month `elem` [M "jun", M "sep"] = fare * 2 * sum (employeesIn staffdir <$> luckyStates)
    | otherwise = 0

  employeesIn :: StaffDirectory -> State -> Int
  employeesIn (SD es) s =
    length $ filter (s ==) (state <$> es)

  main = do
    let staffdir = SD [ E "CA" "US"
                      , E "BC" "CA"
                      , E "ON" "CA"
                      , E "PA" "US"]
    let pf = 100
    print $ travelBudget (M "jun") 100 staffdir ["CA", "BC"]
#+end_src

Let's try it in L4. We note that the record types for objects in L4 are less monomorphic than in Haskell, which is why we allow some staff to have "province" and other staff to have "state" attributes; we basically want our objects to feel loosey-goosey, the way a generation of JSON and MongoDB programmers have learned to expect.

#+begin_src sql
  GIVEN planeFare, staffDir, month
  DEEM travelBudget = numberOf(Employees) * planeFare * 2
  WHEN month ~ ["jun", "sep"]
       staffDir.Employees.country ~ ["CA","US"]
       staffDir.Employees.[province,state] ~ ["BC","CA"]
#+end_src

When there's a list on the right, I pronounce "~" "is in", like with SQL.

The system infers that:
- ~staffDir~ is a record
  - with an ~.employees~ attribute which is a list of records
    - with a ~.country~ attribute of type String
    - with a ~.province~ attribute of type String
    - with a ~.state~ attribute of type String

How does it know that the ~.employees~ attribute is a list of records? Easy: If ~.employees~ were merely a regular attribute it would be have been in lowercase. On the other hand, it's possible that we represent employees as a dictionary of employeeID to employee record; in that case, Employees would be the list of employee IDs.

Note that the repeated use of Employees continues to refine the constraint on Employees.

The first use unifies Employees with all the elements of the list whose ~.country~ is ~"CA"~ or ~"US"~.

The second use further constrains Employees to those whose ~.province~ or ~.state~ attributes are ~"BC"~ or ~"CA"~.

The resulting Employees is available to the main body of the DEEM, where numberOf, aka "length", turns it into an Int, and it participates in the math expressions.

Simple data types:
- String
- Numberlike

Complex data types include Lists, Records, and Maybes.

Currencies desugar to a Record of ~{currency: String, rawAmount: Int}~ where an importable module provides rows like ~{currency: "USD", bigName: "dollar", smallName: "cent", bigAmount: 100, smallAmount: 1}~

Numberlikes can be composed using the usual algebraic expressions.

Currencies can add and subtract only if they are the same currency. They can be composed with numberlikes with multiplication and division.

ObjAttrs are dot-separated strings used to represent objects and variables. Typically, they look like ~alice.address.1~ or ~alice.name.first~.

They can also contain uppercase words, for term unification: ~mycontract.parties.Party~ unifies Party against all elements of the ~parties~ array attribute, and can be subsequently used in a logic match:

~mycontract.parties.NorthAmericans.country ~ ["US" | "CA"]~

binds NorthAmericans to all those parties whose country matches US or matches CA. It is a list of parties.

~mycontract.parties.NorthAmericans.[state,province] ~ ["WA" | "BC"]~

further constrains NorthAmericans to those parties whose state is WA or province is BC.

***** Type Annotations

#+begin_src bnfc :noweb-ref l4bnfc
  TU.        TypeUnify      ::= "::" "Unify";
  TS.        TypeString     ::= "::" "String";
  TB.        TypeBool       ::= "::" "Bool";
  TM.        TypeMath       ::= "::" "Math";
  TOM.       TypeObjMethod  ::= "::" "ObjMethod";
  TT.        TypeTemporal   ::= "::" "Temporal";
#+end_src

A menagerie of data types

#+begin_src bnfc :noweb-ref l4bnfc

  rules      VarExpr   ::= MathExpr | BoolExp | PlainVal;
  rules      PlainVal  ::= String 
                         | BraceList | ArrayOfBraces
                         | DateTime | DateTime "to" DateTime;

#+end_src

Math expressions

#+begin_src bnfc :noweb-ref l4bnfc
  rules      MathExpr   ::= MathExpr  "+" MathExpr1
                          | MathExpr  "-" MathExpr1;
  rules      MathExpr1  ::= MathExpr1 "*" MathExpr2
                          | MathExpr1 "/" MathExpr2 ;
  rules      MathExpr2  ::= CurrencyPrefix MathExpr3 ;
  rules      MathExpr3  ::= Numberlike
                          | ObjMethod TypeMath
                          | ObjMethod ;
  coercions  MathExpr 3;
  rules      Numberlike ::=        Numeric
                          |        Numeric "%";
  rules      Numeric    ::= Integer | Double ;
  NoCurrency.   CurrencyPrefix ::= ;
  CurrCode.     CurrencyPrefix ::= ":" UIdent ":" ;
  CurrDollar.   CurrencyPrefix ::= "$";
#+end_src

Currency expressions

Currencies are expressed specifically as ~:SGD: 1400~ or generically as ~$~. When it's a currency variable you gotta prefix it, sorry. It'll go away when we have better type inferencing later.

Many contracts deal with dollar calculations. L4 supports composable primitives and functional idioms for mathematical expressions.

We pretend that currency expressions are a subset of math expressions.

Boolean expressions

#+begin_src bnfc :noweb-ref l4bnfc
  BAnd1.     BoolExp    ::= BoolExp "&&"  BoolExp1;
  BAnd2.     BoolExp    ::= BoolExp "AND" BoolExp1 ;
  BOr1.      BoolExp1   ::= BoolExp1 "||"  BoolExp2;
  BOr2.      BoolExp1   ::= BoolExp1 "OR"  BoolExp2;
  BLikely.   BoolExp2   ::= Likelihood    BoolExp3;
  BNot1.     BoolExp4   ::=          "!"  BoolExp5;
  BNot2.     BoolExp4   ::=        "NOT"  BoolExp5;
  ObjEq.     BoolExp5   ::= BoolExp5 "==" BoolExp6;

  Likely.    Likelihood  ::= "LIKELY" ;
  Unlikely.  Likelihood  ::= "UNLIKELY";
#+end_src

A boolean expression can be labeled Likely or Unlikely to serve as a hint to a reasoner.

At the moment this syntax is static. In the future it would be nice to be able to compute the likelihood of a constraint expression dynamically.

Boolean expressions comparing math expressions

#+begin_src bnfc :noweb-ref l4bnfc
  MathLT.    BoolExp6   ::= MathExpr "<"  MathExpr;
  MathLTE.   BoolExp6   ::= MathExpr "<=" MathExpr;
  MathGT.    BoolExp6   ::= MathExpr ">"  MathExpr;
  MathGTE.   BoolExp6   ::= MathExpr ">=" MathExpr;
  MathEq.    BoolExp6   ::= MathExpr "==" MathExpr;
#+end_src

Boolean expressions comparing math expressions

Boolean expressions comparing strings

#+begin_src bnfc :noweb-ref l4bnfc
  StrEq1.    BoolExp6   ::= String "==" ObjMethod ;
  StrEq2.    BoolExp6   ::= ObjMethod "==" String ;

  BMatch.    BoolExp6   ::= MatchExpr ;

  BTrue.     BoolExp7   ::= TrueBool; -- later, maybe | "yes" as well
  BFalse.    BoolExp7   ::= FalseBool;
  coercions  BoolExp 7;

  token TrueBool  ["Tt"] ["Rr"] ["Uu"] ["Ee"] ;
  token FalseBool ["Ff"] ["Aa"] ["Ll"] ["Ss"] ["Ee"];

#+end_src

Match expressions against lists

#+begin_src bnfc :noweb-ref l4bnfc
  ME_rbjl.   MatchExpr  ::= MatchExpr RelBool MatchExpr1 ;
  rules      MatchExpr1 ::= ObjMethod -- untyped version creates 33 reduce/reduce conflicts
                          | ObjMethod TypeBool 
                          | JunctionList ;
  coercions  MatchExpr 2;
  rules      RelBool    ::= "IS" | "ISA" | "ARE" | "HAS" | "~";

  rules      ObjMethod  ::= [UnifyElem] Args ;
  rules      Args       ::= | "(" [Constraint] ")";

#+end_src

Unification expressions

#+begin_src bnfc :noweb-ref l4bnfc
  rules      UnifyExpr ::= ObjAttrElem "." [UnifyElem] ;
  rules      UnifyElem ::= ObjAttrElem
                        |  UnifyBracket
                        |  UnifyStar;
  separator nonempty UnifyElem ".";
  rules      UnifyStar ::= "*" ;
  rules      UnifyBracket ::= "<" [CommaElem] ">" ;
#+end_src

"*" is the simplest pattern-match: it matches any value of any attribute.

More complex pattern-matches can be specified using double square brackets. In future we want this to be single square brackets, maybe when we are less scared of reduce/reduce conflicts at the moment.


***** Lists

Most programming languages have the concept of lists, or arrays. Usually, elements of those lists are separated by commas.

In L4, comma lists work as usual. But we also have and-lists and or-lists, which are separated by "&" and "|" respectively.

Internally we call these "junction lists" for "conjunction" and "disjunction".

The semantics depend on context:

| symbol | set context  | propositional context |
|--------+--------------+-----------------------|
| &      | intersection | and                   |
| \vert  | union        | or                    |

#+begin_src bnfc :noweb-ref l4bnfc
  -- what we realy want to be able to do is have a List a

  JL_And.    JunctionList ::=    AndList  ;
  JL_Or.     JunctionList ::=     OrList  ;
  JL_Xor.    JunctionList ::=    XorList  ;
  JL_Comma.  JunctionList ::=  CommaList  ;

  CommaList.  CommaList ::= "[" [CommaElem] "]";
  rules      CommaElem ::= ObjMethod | String;
  separator nonempty CommaElem ",";

  AndList.   AndList ::= AndElem "&" [AndElem];
  rules      AndElem ::= ObjMethod | String;
  _.         AndList ::= "[" AndList "]" ;
  separator nonempty AndElem "&";

  OrList.    OrList ::= OrElem "|" [OrElem];
  rules      OrElem ::= ObjMethod | String;
  _.         OrList ::= "[" OrList "]" ;
  separator nonempty OrElem "|";

  XorList.   XorList ::= XorElem "^" [XorElem];
  rules      XorElem ::= ObjMethod | String;
  _.         XorList ::= "[" XorList "]" ;
  separator nonempty XorElem "^";

#+end_src

***** term primitives

L4 uses customary ~record.attribute~ notation. It does not support ~object(method)~ notation at this time.

#+begin_src bnfc :noweb-ref l4bnfc

  rules      ObjAttrElem  ::= Ident | UIdent ;            -- Foo

  OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
  separator nonempty ObjAttrElem ".";
  separator nonempty ObjAttr     ",";
#+end_src

***** ENTITY stanzas create individuals and classes.

These stanzas represent what Ken Adams calls Langauge of Declaration.

This is where you park details about parties and other concrete entities involved in a contract.

ENTITY stanzas contain optional Limbs: Given, With, As Of, Where.

TODO -- allow LangStrings here, so the initial ObjAttr is an EntityID
#+begin_src bnfc :noweb-ref l4bnfc
  REntity.   Entity ::= "ENTITY" ObjAttr GivenLimb "ISA" ObjAttr WithLimb Asof WhenLimb WhereLimb;
#+end_src

The "Given" limb is analogous to providing arguments to a function.

#+begin_src bnfc :noweb-ref l4bnfc

  rules      GivenLimb ::= | "GIVEN"  GivenExpr ;
  rules      GivenExpr ::=   [ObjAttr]
                           | [ObjAttr] HavingLimb ;
  rules     HavingLimb ::= "HAVING" "{" [HavingBoolExp] "}";
  rules     HavingBoolExp ::= BoolExp;
  separator nonempty HavingBoolExp ";";

#+end_src

The "With" limb assigns attributes to an individual or a class.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      WithLimb  ::= | "WITH" "{" [WithIn] "}";
  rules      WithIn    ::= [Constraint] | TraceExpr;
  separator nonempty WithIn ";";
#+end_src

A "Trace" is syntactic sugar for a "With" limb for perdurants -- facts about an individual or a scenario that are bounded in time.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      TraceExpr ::= "TRACE" "{" [LogEvent] "}";
  rules      LogEvent ::= Iso8601 ObjAttr ObjAttr [Blah] ;
  separator nonempty LogEvent ";";
  separator Blah "";
  rules      Blah     ::= VarExpr;
#+end_src

"Where" offers bindings similar to those found in Haskell. This is a convenient place to go into detail about concepts which are mentioned briefly in the main body.

#+begin_src bnfc :noweb-ref l4bnfc
  rules     WhereLimb ::= | "WHERE" "{" [WhereExp] "}" ;
  rules     WhereExp  ::= Constraint WithLimb WhenLimb WhereLimb ;

  separator nonempty WhereExp ";";
#+end_src

***** The "ASOF" Limb and time formats

We support ISO8601 dates and times.

In the future a more comprehensive time library will make it possible to say things like "the fourth Friday of every month, failing which the third Thursday."

The "ASOF" limb is syntactic shorthand for indicating a default system time for "WITH" facts declared immediately prior.

#+begin_src bnfc :noweb-ref l4bnfc
  Asof.      Asof      ::= "ASOF" DateTime ;
  AsofNull.  Asof      ::= ;
  rules      DateTime  ::= Iso8601 | "PRESENT" | "NOW" ;
  rules      Iso8601   ::= YYYYMMDD | YYYYMMDDTHHMM;

  token YYYYMMDD      ( digit digit digit digit '-'? digit digit '-'? digit digit );
  token YYYYMMDDTHHMM ( digit digit digit digit '-'? digit digit '-'? digit digit 'T' digit digit digit digit );
#+end_src

***** Syntax Primitives

Higher-level constructs rely on syntax primitives.

#+begin_src bnfc :noweb-ref l4bnfc
  token UIdent (upper (letter | digit | '_')*) ; -- doesn't seem to work for single character idents though, like P
  rules      UIdentList ::= [UIdentElem];
  rules      UIdentElem ::= UIdent;
  separator nonempty UIdentElem ".";

#+end_src

"WITH" limbs look like "foo == bar". But they're actually constraint relations, and you can do multiples of them.

#+begin_src bnfc :noweb-ref l4bnfc
  rules BraceList     ::= "{" [Constraint] "}" ;
  rules  Constraint   ::= ObjAttr ConstraintBinOp VarExpr;
  rules ArrayOfBraces ::= "[" [BraceList] "]";
  separator nonempty Constraint  "," ;
  separator nonempty BraceList   "," ;
  rules ConstraintBinOp ::= "=" | "<" | ">" | "<=" | ">=" | "==" | "IS" | "ISA" | "ARE" | "HAS";
#+end_src

***** SCENARIO stanzas represent traces of events

#+begin_src bnfc :noweb-ref l4bnfc
  RScenario. Scenario ::= "SCENARIO" ObjAttr WithLimb TraceExpr Asof WhereLimb ;
#+end_src


**** Meta-Rules: Interactions and priority

***** Notwithstanding

***** Subject To

***** Scope


**** Text Examples

#+begin_src text :noweb yes :tangle bnfc/l4/test1.l4
  // this is auto-generated from README.org. Use C-c C-v C-t to output a fresh version of this file.
  <<l4-example1>>

  <<l4-rules>>

  // the Prolog version of the above is:
  // isEdiblePotato(Item) :- isPotato(Item), isEdible(Item).
  // isTastyFood(Item)    :- isPotato(Item), isEdible(Item).
  //
  // the Flora-2 version of this would probably rely on the Item having properties
  //


  // Meng seems to be reinventing Haskell
  // let's call it HasSQL, haha

  /* like, for example ...

  append "poo" forEach [Foo, Bar, Baz]

  is equivalent to, in some other languages,

      [Foo, Bar, Baz].map(x=>x+"poo")
  or
      (++ "poo") <$> [foo, bar, baz]

  so we can sneak that in to our language too, just with lots of
  syntactic sugar so the "business developers" don't notice we're doing
  a list comprehension

  ,*/

  <<l4entity>>

#+end_src

***** Inference

The Cabbage case provides a good example of /normalization/. We present a few equivalent ways of saying the same thing, thanks to the inference rules of modal logic.

Let's start with the simple case:

- NOBODY MAY          sell Item
- PARTY * AS P1 SHANT sell Item
- PARTY * AS P1 MUST NOT(sell Item)

First, a point of syntax: we use the keyword ~SHANT~ to represent ~MUST NOT~.

While colloquially "may not" means "must not", in our syntax the term ~MAY NOT X~ does not mean ~SHANT X~ -- it does not bind as ~(MAY NOT) X~, but it binds as ~MAY (NOT X)~ instead. It means that you are allowed to not do X, but it is silent on whether you are prohibited from doing X.

In short, prohibition is best written "SHANT", but may also appear as "MUST NOT" or "NOT MAY".

Modal operator binding appears to be right-associative, as does negation.

| SHANT | <-> | MUST NOT | <-> | NOT MAY |

We induce an inference rule:

| NOBODY MAY X   | <-> | EVERYBODY SHANT X     |
| NOBODY SHANT X | <-> | EVERYBODY MAY X       |
| NOBODY MUST X  | <-> | EVERYBODY MAY (NOT X) |

Now what happens if we add a WHEN constraint?

- NOBODY MAY sell Item WHEN Item IS Nasty

Depending on our logic model, we may or may not choose to infer complementary deontics above the condition. In other words: *What about non-nasty items? Are they allowed to be sold?*

- NOBODY MAY sell Item <--IFF--> Item IS Nasty

In logic, this is the difference between

| well-founded semantics  | standard model semantics   |
| ternary logic           | binary logic               |
| Prolog                  | first-order logic          |
| intuitionistic logic    | law of the excluded middle |
| closed-world assumption | negation as failure        |

This also goes to a bigger point about "fail open" vs "fail closed" systems of law: https://en.wikipedia.org/wiki/No_U-turn_syndrome contrasts two defaults:

- everything not explicitly permitted is prohibited 
- everything not explicitly prohibited is permitted

Suppose we want to live in a *permissive* world. We license inference of the form:

| P SHANT X WHEN Y | --> | P MAY X WHEN NOT Y       |
| P MAY X WHEN Y   | --> | P.X undefined WHEN NOT Y |
| P MUST X WHEN Y  | --> | P MAY NOT X WHEN NOT Y   |

Suppose we want to live in a *prohibitive* world. We license inference of the form:

| P SHANT X WHEN Y | --> | P.X undefined WHEN NOT Y |
| P MAY X WHEN Y   | --> | P SHANT X WHEN NOT Y     |
| P MUST X WHEN Y  | --> | P.X undefined WHEN NOT Y |

Note that permissive and prohibitive inference rules are themselves complementary.

If we want to live in a *passive* world, we could say that everything is simply undefined when not Y:

| P SHANT X WHEN Y | --> | P.X undefined WHEN NOT Y |
| P MAY X WHEN Y   | --> | P.X undefined WHEN NOT Y |
| P MUST X WHEN Y  | --> | P.X undefined WHEN NOT Y |

If we want to live in an *assumptive* world, we could always take the inference when not Y:

| P MUST NOT X WHEN Y | --> | P MAY X WHEN NOT Y       |
| P MAY X WHEN Y      | --> | P SHANT X WHEN NOT Y     |
| P MUST X WHEN Y     | --> | P MAY NOT X WHEN NOT Y   |

More on this later.

This is a little bit analogous to the "Men Are Scum" "#NotAllMen" arguments that need to be disambiguated using Exists vs ForAll quantifiers.

***** About Non-Monotonic Logics

Meng is skeptical about non-monotonic logics. In short, if you run a function with different arguments, of course you should expect to get different results.

**** TODO Syntax Sketchbook

Random bits of syntax Meng has made up over the years

#+begin_example
    LEGALSOURCE  SG.Cap50.175.1
REGULATIVE RULE  "Companies Must Hold AGM" @ cmhagm
     SUBJECT TO  this§ & §175A
          PARTY  EVERY Company
          PMUST  hold (a general meeting called@ "annual general meeting") @ AGM
          WHERE  AGM.labels == 1 [ text_en= "in addition to any other meeting" ]
     REPEATEDLY
          AFTER  EACH Company.financialYearEnd
         WITHIN  Company.isListedPublicCo?
                 THEN 4 months
                 ELSE 6 months
#+end_example

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $ stack exec hs-exe
DEFINITION RULE "egm business"
FORALL Company.generalMeetings.isExtraordinary?.business {
  .level == Special
}

DEFINITION RULE "agm business"
FORALL Company.generalMeetings.isAnnual?.business {
  .level = Special
           UNLESS .matter ~~ [ "the declaration of a dividend",
                               "consideration" OF [ "the financial statements",
                                                    "the reports of the auditors"
                                                    &&
                                                    "the statements of the directors" ],
                               "the election of directors in the place of retiring directors"
                               ||
                               [ "the appointment"
                                 &
                                 "fixing of the remuneration" ] OF "the auditors" ]
}

UNSPOKEN DEFINITION RULE "metonym: the ontological essence of a meeting's business is its matter attribute"
FORALL Company.generalMeetings.business {
  :metonym = .matter
}

REGULATIVE RULE "must hold agm"
PARTY Company, a corporation
MUST hold an AGM
     :en: hold an AGM
REPEATEDLY every 1 year

REGULATIVE RULE "Companies Must Hold AGM"
PARTY Company, a corporation
PMUST hold an AGM
      :en: hold a general meeting called "annual general meeting"
      :en: in addition to any other meeting
      WHERE NOT (CHMAGM ~~ unique constraint excludes any other label on this meeting)
REPEATEDLY every 1 year

UNSPOKEN CONSTITUTIVE RULE "a listed public company"
FORALL Company {
  .isListedPublicCo? :- .isPublic?, .isListed?.
}
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $
#+end_example

***** Jason's Draft of the SAFE

#+begin_example
Safe_Contract IS A CATEGORY OF CONTRACT THAT:
    HAS PARTY Investor
    HAS PARTY Company
    HAS JURISDICTION State_of_Incorpration
    HAS DATE Executed_On
    HAS CURRENCY Purchase_Amount
    HAS CURRENCY Post-Money_Valuation_Cap
    HAS NUMBER Discount_Rate
    HAS FLUENT BOOLEAN Terminated

Equity_Financing IS A CATEGORY OF EVENT THAT:
    HAS A LIST OF DOCUMENTS Required_Documents
    HAS BOOLEAN Documents_Are_Standard

START SCOPE This_SAFE as Safe_Contract

    RULE "Certifications"
    Investor MUST pay Purchase_Amount to Company
    BEFORE Executed_On + 1W
    HENCE "Right to Shares"

    START SCOPE "Right to Shares"

        START SCOPE "Events"

            RULE "Equity Financing"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False)
                THEN
                    Company MUST give Investor Amount of Safe_Preferred_Stock
                    WHERE
                        Amount = Purchase_Amount / Conversion_Price
                HENCE "Required Documentation", "Termination By Equity Event"

            RULE "Required Documentation"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False) AND
                    E.documentation.isStandard
                THEN
                FOR EACH Document in E.Required_Documents
                    Investor MUST
                        execute Document
                        AND THEN                        // sequential, not logical
                        deliver Document to Company  

            // RULE "Liquidity Event" ...

            // RULE "Dissolution Event" ...

            Rule "Termination By Equity Event"

                GIVEN Event T
                WHEN
                    T ~ Company give Investor Amount of Safe_Preferred_Stock
                THEN
                    This_SAFE.Terminated = True
					
        END SCOPE "Events"
    END SCOPE "Right to Shares"
END SCOPE This_SAFE

#+end_example
**** A Scope Statement

*** Expressions

#+begin_src bnfc :noweb-ref l4expressions
EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= LangID NormalString ;
rules         LangID       ::= ":" [LangLabel] ":";
rules         LangLabel    ::= Ident ;
    separator nonempty LangLabel "," ;

rules         CurrID       ::= ":" CurrLabel ":";
rules         CurrLabel    ::= UIdent ;
#+end_src

**** String

A normal string looks ~"like this"~ and obeys the usual conventions around escaped backslashes, quotes, and newlines.

**** Language String

A language string is a normal string prefixed with a language ID prefix. Any place you can have one language string, you can have more:

#+begin_example
:en:"potato"
:fr:"pomme de terre"
#+end_example

**** Language Identifiers

A language ID prefix is one or more comma-separated ISO639-1 language codes, where dashes and underscores are accepted.

**** Language Stringset

A Language Stringset is one or more language strings separated by whitespace.

**** Lists

***** Plain Lists

Today's available flavours are: ~[Chocolate, Vanilla, Strawberry]~

***** Conjunctive Lists

The whole situation is a mess.

https://www.lectlaw.com/def/c282.htm says: "There are many cases in law where the conjunctive 'and' is used for the disjunctive 'or' and vice versa."

***** What is the total space?

Read chapter 11 of MSCDv4. The remainder of this section attempts to formalize all of the possible variants from that chapter.

***** Is there a better way?

L4 is a formal language. The meanings of expressions are explicitly defined.

****** Ternary Logic In L4: "three-valued Booleans"

Let ~p :: a -> Ternary~, which is to say, ~p~ is a predicate; given an input of type ~a~, it will always return Yes, No, or Neither -- "neither" meaning "unknown", "undefined", "null", or "wat". This is an example of a [[https://en.wikipedia.org/wiki/Three-valued_logic][ternary logic]].

Here's a predicate: "has five toes on each fore paw". Most cats, the predicate returns ~true~. But some cats have [[https://en.wikipedia.org/wiki/Polydactyl_cat][polydactyly]]. It's an unusual condition. You can count the number of polydactyls per thousand, on the fingers of ... uh, let's just say it's a rare condition. For them, the predicate would return ~false~.

But what about an amputee, who has no forelegs? They don't have six toes on each foot. They don't have five toes on each foot. They don't have feet at all.

What is the hair colour of a bald man?

What is the airspeed velocity of an unladen Martian swallow?

On a form, you would write in "N/A" for "Not applicable".

That's why we need ternary logic: sometimes yes, sometimes no, sometimes neither.

Here's another predicate: "tailless". The Manx breed are considered tailless -- they are "rumpies" and "stumpies".

A cat is special if it is polydactyl.

A cat is special if it is tailless.

A cat is valuable if it is both polydactyl and tailless.

I wanted to say "a cat is special if it is polydactyl or tailless", but that brings up "exclusive or" considerations -- some might say "if it is both polydactyl and tailless than it isn't special, because it's obviously valuable instead." They're reading "xor" into the "or", in the context of the next sentence.

It isn't logical, but it's English!

So we spare ourselves all that grief by giving explicit definitions. Watch.

****** Junction Lists

TO BE CONTINUED

Basically we have

| set theory   | propositional logic | symbol |
|--------------+---------------------+--------|
| union        | or                  | \vert  |
| intersection | and                 | &      |

| example               | ~ | list        | means                           |
|-----------------------+---+-------------+---------------------------------|
| some.Unification.term | ~ | [x & y]     | forall u in U, exists u in {x, y} |
| some.Unification.term | ~ | [x \vert y] | exists u in U, exists u in {x, y} |

In Haskell, ~Data.List.all~ tests a single predicate against a collection of ~a~ values. You can say: the members of the Polydactyly Society are ~all polydactyl~. "Polydactyl" is the predicate. "The Polydactyly Society" is the collection. ~all polydactyl society~ returns ~True~.

#+begin_src haskell
  polydactyl :: Cat -> Bool
  polydactyl cat = length cat.frontLeft.toes  > 5 ||
                   length cat.frontRight.toes > 5

  society = filter polydactyl allcats
#+end_src

But sometimes you want to test a single value against a collection of predicates. Sometimes you want all the predicates to match.

#+begin_example
kitchen.canMakeNeapolitan = kitchen ~ [ hasChocolate
                                      & hasVanilla
                                      & hasStrawberry ]
#+end_example

Sometimes you want to test if any of the predicates match.

#+begin_example
dish.isDangerous = dish ~ [ hasPeanut     -- (hasPeanut dish) == True
                          | hasWalnut
                          | hasAlmond ]
#+end_example

The machinery for this:

#+begin_src haskell :tangle bnfc/blah/Preds.hs
module Preds where

  allPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  allPreds preds value = all (flip ($) value) preds

  anyPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  anyPreds preds value = any (flip ($) value) preds

  numPreds ::                [ a -> Bool ] -> a -> Int
  numPreds preds value = length (filter (flip ($) value) preds)

  xorPreds ::                [ a -> Bool ] -> a -> Bool
  xorPreds preds value = 1 == numPreds preds value

#+end_src

In L4, collections of predicates are called "junction lists". The term comes from "conjunctions" and "disjunctions", hence "junctions".

In L4, a *conjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~&~ character, for "and".

In L4, a *disjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~|~ character, for "or".

In L4, an *exclusive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~X~ character, for "exclusive or".

In a junction list of three or more elements, the earlier predicates in the list can be separated by a comma "," or by the same as the final separator.

This makes it easy to write:

#+begin_example
  cats = [ alice
         , bob
         , carol
         , dan
         ]

  special = [ polydactyl
            | tailless 
            ]

  valuable = [ polydactyl
             & tailless 
             ]
#+end_example

Conjunctive lists are syntactic sugar for ~all~.

Disjunctive lists are syntactic sugar for ~any~.

Exclusive lists are syntactic sugar for ~oneOf~.

Lists can nest.

Next we talk about matching.

#+begin_example
  specialCats  = [ polydactyl | tailless ] cats
  valuableCats = [ polydactyl & tailless ] cats

  // note that we do NOT support these alternatives in L4 syntax:
  specialCats  = any [ polydactyl, tailless ] cats
  valuableCats = all [ polydactyl, tailless ] cats

  dish.isDangerous = dish [ hasPeanut
                          , hasWalnut
                          | hasAlmond ]
#+end_example

Space application is overloaded as follows:

| LHS            | RHS              | meaning                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | single value     |                                                 |
| single value   | junction list    | boolean                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | list of values   | filter for values which match the junction list |
| list of values | junction list    | filter for values which match the junction list |
|----------------+------------------+-------------------------------------------------|
| list of values | single predicate |                                                 |

The semantics of a conjunctive list:
#+begin_src haskell :tangle bnfc/blah/Matchable.hs
  module Matchable where

  -- TODO: make this work!

  class Matchable a where
    match  :: (Eq a, Foldable t) => a -> t a -> Bool

  newtype ConjList a = ConjList [a]
  newtype DisjList a = DisjList [a]

  instance Matchable (ConjList a) where
    match x = all (== x)

  instance Matchable (DisjList a) where
    match x = any (== x)
#+end_src

****** "Any" and "all"

Yay English! What's the difference between

"Any zombies will be shot on sight"

and

"All zombies will be shot on sight"

?

No difference!

This is why it's dangerous to reuse words with a rich existing history -- at some point, people will guess wrong.

First-order logic knows how to deal with this situation. That's why we have \exists and \forall.

See also https://inariksit.github.io/cclaw-zettelkasten/ambiguity_of_and.html

**** Namespace Attributes

***** Automatic singular / plural support

In normal languages, ~object.party~ is a different attribute than ~object.parties~.

However, our language knows English grammar, so those two attributes automatically bind to the same referent, allowing more natural expression:

- ~object.party[A]~
- ~object.party[B]~
- ~object.parties[ALL]~
- ~object.parties[A & B]~
- ~object.parties[A | B]~

This may turn out to be a bit of a gotcha.

*** Defining Objects and Attributes

As in Javascript, objects contain a dictionary of attributes.

As in Haskell, we'd talk about a record type.

**** Multitemporality

Unlike Javascript, an attribute may be /multitemporal/:
- valid time
- transaction time
- decision time

An attribute is also /multivalent/: by default, every attribute of an object can have zero or more values; informally speaking, every attribute of type X is really a list of X.

Let's take a simple example. As in Typescript, we define an instance type for a human:
- human.birthdate :: Date
- human.fullname :: String
- human.nationality :: Country

Take Neta-Lee Hershlag. She was born in Israel in 1981; at least, that is what Wikipedia believes, as of the 10th of September 2020 when I wrote this.

Guess what, though. She holds dual Israeli and American citizenship. Unusual, right? Most ontologies would only allow one citizenship to a person. Bit of a black swan. Let's use that as her codename.

#+begin_src haskell :noweb-ref l4entity
  ENTITY blackSwan
     ISA Human
    WITH birthdate = { xtime = 2020-09-10, value = 1981-06-09 }
  //     a person can have multiple nationalities
         nationality = [ { xtime = 2020-09-10, value = "IL", vtime = 1981-06-09 to PRESENT }
                       , { xtime = 2020-09-10, value = "US"                                } ]
#+end_src

We assume that her Israeli citizenship began at birth, but Wikipedia doesn't know when she became a US citizen; all we know is that as of September 10 2020, Wikipedia said she is one. So that citizenship value doesn't define a vtime.

Let's not commit the usual [[https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/][falsehoods programmers believe about names]]. Can someone have multiple names? Sure, why not? Some people change their names when they get married; others when they switch genders; lots of variability. Sometimes people just have multiple names at the same time. Our Black Swan does too:

#+begin_src haskell :noweb-ref l4entity
  //     a person can have multiple names
         fullname    = [ { xtime = 2020-09-10, value = ["Neta-Lee Hershlag", "Natalie Portman"] } ]
#+end_src

As you can see, the "multitemporal" syntax allows us to easily handle scenarios like:
- On January 1, celebrities X and Y were known to be dating.
- By July 1, paparazzi sleuths found out that X and Y had gotten married some time in the past few months; the ceremony was said to have been held on a private island, but nobody's saying where or when it happened.
- On September 1, the couple spilled the details and shared that the wedding had happened on June 1.
- On December 1, the couple announced that they had gotten divorced on November 1.

#+begin_src haskell :noweb-ref l4entity
  ENTITY celebXY
   GIVEN Tabloid HAVING ceaselessCoverage :: Bool
     ISA Couple
    WITH xtime = 2020-01-01, maritalStatus = dating
         xtime = 2020-07-01, maritalStatus = married
         xtime = 2020-09-01, maritalStatus = married,  vtime = 2020-06-01 to PRESENT
         xtime = 2020-12-01, maritalStatus = married,  vtime = 2020-06-01 to 2020-11-01
         xtime = 2020-12-01, maritalStatus = divorced, vtime = 2020-11-01 to PRESENT
#+end_src

The "transaction time" shows when the system know something; the "valid time" shows when some situation was the case. This allows one to compute "on this date, what did we know? What was actually true?"

**** Epistemics

An attribute may also be /epistemic/:
- on August 1, Alice learned that she was pregnant
- on September 1, Alice wrote a letter to Bob telling him that she was pregnant, and sent it via registered post.
- by the notice terms of their pre-nup, Bob was deemed to receive notice three days after the mail was sent, on September 4.
- on October 1, Bob claimed to have actually received the notice on September 10, due to difficulties with the postal service.

#+begin_src haskell :noweb-ref l4entity
  SCENARIO alicePregnancy
     TRACE 2020-08-01 Alice knew { pregnancy = true }
           2020-09-01 Alice told Bob { knownBy = Alice, pregnancy = true }
           2020-09-01 Alice knew { knownBy = Bob,  vtime = 2020-09-04, beliefs = { knownBy = Alice, pregnancy = true } }
           2020-10-01 Bob   knew { knownBy = Alice, beliefs = { knownBy = Alice, pregnancy = true, vtime = 2020-09-01 }, vtime = 2020-09-10 }
#+end_src

There should be as many xtimes as there are knowers.

*** Inference: Querying Objects and Attributes



We can ask fine-grained questions like:
- On a given date, what did entity E, or The Public, or The System generally, believe to be true about some entity E, or some unit of knowledge K?

By default, L4 expressions will default to the latest known information at the time of decision.

**** Using Object Attributes

Okay. Deep breath. Lower case and upper case are meaningful.

Specific individuals are lowercase, like blackSwan, or celebXY.

Interfaces, or classes, start with an uppercase letter, like Human or Couple.

Knols are belief structures, and have special attributes ~knownBy~, ~toldBy~, ~toldTo~, and ~beliefs~ attributes. This may go away at some point.

We use the "ASOF" keyword to give all the attributes a default ~xtime~ (transaction time). If it is omitted, it defaults to the execution time.

#+begin_src haskell :noweb-ref l4entity
  ENTITY veggieBar
     ISA Business
    WITH address = [ "1 Veggie Way" ]
         id      = { idtype = "UEN", idval = "202000000A" }
         name    = "The Veggie Bar Pte. Ltd."

  ENTITY buyCabbage
     ISA ContractOfSale
    WITH date         = 2020-09-10
         jurisdiction = SG
         buyer        = blackSwan
         seller       = veggieBar
         buyer.consideration  = :USD: 10
         seller.consideration = [ item1, item2 ]
    ASOF 2020-09-10
   WHERE item1 ISA  Item
               WITH category = "vegetable"
                    species  = "Brassica oleracea"
                    cultivar = "capitata"
#+end_src

ContractLaw is a library class which abstracts the essential elements of a particular contract.

An alternative representation shows a trace of events:

#+begin_src haskell :noweb-ref l4entity
  SCENARIO saleHistory
    WITH parties = [ blackSwan, veggieBar ]
   TRACE 2020-09-01T1210 blackSwan offers     offerDetails
         2020-09-01T1211 veggieBar accepts    offerDetails
         2020-09-01T1212 blackSwan pays       veggieBar $10
         2020-09-01T1213 veggieBar deliversTo blackSwan [ item1, item2 ]
    ASOF 2020-09-10
   WHERE offerDetails = { blackSwan.consideration = $10
                        , veggieBar.consideration = [ item1, item2 ] }
         item1 ISA Item
               WITH category = "vegetable"
                    species  = "Brassica oleracea"
                    cultivar = "capitata"
                    quantity = 1
         item2 ISA Item
               WITH category = "beverage"
                    brand    = "Acme Water"
                    model    = "750mL"
                    quantity = 1
#+end_src

from which a pattern-matcher could deem that a legal contract was in place. Let's see what that looks like:

**** Natural Language Generation

#+begin_src text :noweb-ref l4-rules
  RULE 1 ruleOne :en:"First Rule" NOOP
#+end_src

What should this say in English?

"First Rule. This rule does nothing."

**** Matching Object Attributes

What you're about to read is basically a Horn clause. If you know Prolog, you will recognize that this is Prolog, dressed in the guise of an object-like paradigm. You might even say, "this has the same F-Logic as Flora-2", except with the syntax of SQL.

Let's start with a super simple case.

#+begin_src haskell :noweb-ref l4entity
  ENTITY spud1
     ISA Item
    WITH species  = "Solanum tuberosum"
         isEdible = true
#+end_src

This converts to Prolog:

#+begin_src prolog
  species(spud, "Solanum tuberosum").
  isEdible(spud).
#+end_src

If we were converting to Flora-2 we would be more intelligent about classes and inheritance, but we're just trying to get our feet wet with logic programming, so we'll do that another time.

Incidentally, astute readers may remark: "surely ~IS~ and ~ISA~ syntax here is a special case of some more generic n-place arity relational syntax for FOL" -- and you would be right. ~IS~ and ~ISA~ should be macros. This refactoring of the language will happen soon.

Anyway, now we can run Rule2 on it.

#+begin_src text :noweb-ref l4-rules
  RULE 2 edible
   DEEM Item IS EdiblePotato
            AND TastyFood
    WHEN Item IS Potato
     AND Item IS Edible
#+end_src

Rule 2 relies on rule 3. This is backward chaining.
  
#+begin_src text :noweb-ref l4-rules
  RULE 3 isPotato
    DEEM Item IS Potato
    WHEN Item.species ~ ["Solanum tuberosum" | "Mister Potatohead"]

  // an OR-LIST expands to
  // isPotato(Item) :- species(Item, "Solanum tuberosum"); species(Item, "Mister Potatohead").
  //                                                     ^
  // an AND-list would expand to
  // isPotato(Item) :- species(Item, "Solanum tuberosum"), species(Item, "Mister Potatohead").
  //                                                     ^
#+end_src

If this begins to feel weird, it's because under the hood, we're borrowing Prolog's unification and backtracking features.

Suppose potatoes are so rare and prized that they come with certificates of provenance tracing the history of previous owners.

#+begin_src haskell :noweb-ref l4-rules
  ENTITY spud2
     ISA Item
    WITH species  = "Solanum tuberosum"
         isEdible = true
         previousOwners = [ alice, bob, charlie, daryl ]
#+end_src

What does that look like in Prolog?

#+begin_src prolog
  species(spud2, "Solanum tuberosum").
  isEdible(spud2).
  previousOwner(spud2, alice).
  previousOwner(spud2, bob).
  previousOwner(spud2, charlie).
  previousOwner(spud2, daryl).
#+end_src

Now we have an opportunity to explore relational syntax. Think Alloy.

Let's say that some of the previous owners were members of the nobility.

#+begin_src haskell :noweb-ref l4-rules
  ENTITY alice   ISA Human WITH isNoble = true
  ENTITY bob     ISA Human WITH isNoble = false
  ENTITY charlie ISA Human WITH isNoble = true
  ENTITY daryl   ISA Human WITH isNoble = false
#+end_src

In Prolog, that reads:

#+begin_src prolog
  isNoble(alice).
  isNoble(bob).
  isNoble(charlie).
  isNoble(daryl).
#+end_src

Let's say a potato is Noble if at least two of its previous owners are Noble.

There are a couple ways to say that. This is one way:

#+begin_src haskell :noweb-ref l4-rules

  RULE noblePotato
    DEEM Item IS Noble
    WHEN Item ISA Potato
     AND Item.previousOwners.First IS Noble
     AND Item.previousOwners.Second IS Noble
#+end_src

(Maybe this also creates an automatic Item.isNoble?)

That translates to:

#+begin_src prolog
  isNoble(Item) :- isPotato(Item),
                   previousOwner(Item, First), isNoble(First),
                   previousOwner(Item, Second), isNoble(Second),
                   First != Second.
#+end_src

This allows us to subsequently use the term Potato instead of Item:

#+begin_src haskell :noweb-ref l4-rules
  RULE noblePotato2
    DEEM Potato IS Noble
    WHEN Potato.previousOwners.isNoble :: Math >= 2
#+end_src

Alternative syntax:

#+begin_src haskell :noweb-ref l4-rules
  RULE noblePotato3
    DEEM Potato IS Noble
    WHEN Potato.previousOwners.<Owner1,Owner2> IS Noble
#+end_src

*** Library: ContractLaw


#+begin_src haskell :noweb yes :tangle bnfc/l4/ContractLaw.l4
  RULE 1 elements
    :en: "Elements of a Contract"
   GIVEN scenario
    DEEM scenario.hasContract
    WHEN [ parties >= 2
         ,   @ T1 party.Offeror  offers    O
         ,   @ T3 party.Acceptor accepts   O, T1 <= T3
         , ! @ T2 party.Offeror  withdraws O, T1 <= T2 <= T3
         , ! @ T2 party.Acceptor declines  O, T1 <= T2 <= T3
                  -- Note: Acceptor may unify to multiple values, since cardinality of parties can be 3 or more
         , O.Offeror.Consideration
         & O.Acceptor.Consideration
         ]
   WHERE [ O.Offeror.Consideration & O.Acceptor.Consideration ] <&> [ [ isPromiseToRefrain | hasValue ] & not isPast ]
#+end_src

Some unspoken rules are at play:
- disjoint rule :: Acceptor /= Offeror because any match is automatically narrowed to be disjoint with any previous matches of the same shape, unless there is a WHERE expression that explicitly broadens the match to allow X to be Y
- with GIVEN :: namespaces of the GIVEN parameters are available in scope for the rest of the rule
- singular / plural unification :: .parties and .party are automatically the same object

We may want to express that a counteroffer implies a decline.

*** Ontology

AKA a type system

*** Metaprogramming

**** patterns

basically, macro expansions and function definitions

#+begin_src l4
  PATTERN myfirstpattern
  WHEREVER RuleMatchExpr // a lens-style pattern match against one or more rules
  TRANSFORM  AliasExpr
  TO         ReplacementExpr
  ...
#+end_src

TODO For example we expand a rule about potatoes to also apply to cabbages, expanding ~item.isPotato~ to ~(item.isPotato OR item.isCabbage)~ in the body of any Horn clause.



*** Comments

The usual:

=/* text within C-style comment blocks is ignored */=

=// text after Javascript-style comment slashes is ignored to end of line=

** User Guide

*** How To Try It For Yourself

A web REPL? IDE support?

*** Tutorials

This section will link to standalone tutorials that work through case studies for common scenarios.

*** Libraries for Genres:

Each of these genres requires a library -- a "sub-domain ontology".

- Contract Law :: notions of what constitutes a valid contract
- Real Estate ::
- City Planning :: 

*** Formal Verification

How to perform static analysis on the programs.

*** Natural Language Generation

How to compile to natural languages.



** How To Contribute

Github issues.

* Developers Guide

** Requirements

The following command line packages need to be runnable from your shell.

- bnfc
- alex
- happy
- haskell stack
- emacs
  - org-mode

** Install and Quickstart

If you're running the system for the first time, stack will take some time to install ghc.

#+begin_src sh
$ cd bnfc; make
#+end_src

If you're editing the README.org, you can run this to re-make every time you hit save.
#+begin_src sh
$ cd bnfc; fswatch -o ../README.org | perl -nle 'system("clear; date; make")'
#+end_src

This launches a new Emacs to tangle the source files from the README.

Then it builds the L4 interpreter from scratch.

Then it parses the sample L4 code into out/test1.out

** Other Things you can Do
#+begin_src sh
$ ghcid --command "stack ghci" ./mkProlog.hs
#+end_src

** Detailed Compiler Documentation

*** Stages

**** Lexing

handled by BNFC

**** Parsing to Abstract Syntax Tree

handled by BNFC

**** Validation Stage 1

- build a lexical symbol table of defined terms
- Are all defined terms used?
- Identify all undefined terms (which, presumably, would become interview questions in an abductive reasoner)
- distinguish between declared and defined terms

**** Metaprogramming

Any reference to "he" in this document shall be read as "she" where appropriate.

Nothing in this rule shall limit the right to xxx

**** Validation Stage 2

**** Numbering Resolution

**** Cross-Reference Resolution

**** Versioning Resolution

A current rule may refer to an obsolete rule as part of a hypothetical evaluation: /the benefit defined by this rule shall be no lesser than the benefit afforded by any previous version of this rule./

is a clumsy but compact way of saying, evaluate the current rule, evaluate the old rules, and take the max. This requires, in turn, that the old rules be resolvable using the same inputs available to the current rule. If that is not possible, the reasoner needs to raise an error, or ask what to do to handle that situation.


*** Intermediate Representation

So! Thanks to BNFC we have things in Haskell datatypes. That's our abstract representation.

And then we massage those types a bit. We did some validation, verification, inferencing, maybe some rewriting and transformation.

Next we turn those things into concrete outputs.


*** Output Targets

**** Prolog

The transformation looks like this:

- input :: Rule ... Given X ... DEEM X.foo WHEN X.bar AND X.baz
- output :: foo(X) :- bar(X), baz(X).

-#+BEGIN_QUOTE
 *Comment MS:* Does =DEEM= always define a rule (logically speaking: an
 implication), or is there also a mechanism for /definitions/, such as for
 example in the Catala language (which is an equivalence, logically
 speaking)? In the above example, when knowing =X.foo=, one cannot infer that
 =X.bar=. 
-#+END_QUOTE

#+begin_src haskell :tangle bnfc/prolog/ToProlog.hs
  module ToProlog where

  import Data.Char (isUpper, isLower, toTitle, toLower)
  import AbsL
  import Data.List (intercalate)

  class ToProlog a where
    toProlog :: a -> String

  instance ToProlog Rules where
    toProlog (Toplevel toplevels) =
      unlines $ toProlog <$> toplevels

  instance ToProlog Toplevels where
    toProlog (ToplevelsRule rule) = toProlog rule
    toProlog (ToplevelsModule m)   = show m
    toProlog (ToplevelsImport i)   = show i
    toProlog (ToplevelsPragma p)   = show p

  instance ToProlog Rule where
    toProlog (RuleStanza ruledef rulebody) =
      unlines [ unwords [ "%% ruleDef:",   show ruledef ]
              , unwords [ "%% ruleBody:",  show rulebody ]
              , unwords [ toProlog rulebody ]
              ]

  instance ToProlog RuleBody where
    toProlog RBNoop = "%% NOOP lol"
    toProlog (RBDeem objattrands predexpr) = unlines $
      (\(ObjAttrAnd1 objAttr) -> unwords [ toProlog objAttr
                                         , ":-"
                                         , toProlog predexpr ++ "." ])
      <$> objattrands

  #+end_src

Lot of heavy lifting happens in an ObjAttr "token":

| objattr       | prolog        | remark                                         |
|---------------+---------------+------------------------------------------------|
| One.two       | two(One)      | boolean horn                                   |
| One.Two       | two(One,Two)  | Two contains a value for subsequent processing |
| one.two       | one.two       | atom                                           |
| one.Two       | one.Two       | atom                                           |
| one.two.three | one.two.three | atom; should we consider unpacking?            |

Things can get more complicated in Flora-2.

See also https://www.swi-prolog.org/pldoc/man?section=bidicts for an alternative approach we might consider.

  #+begin_src haskell :tangle bnfc/prolog/ToProlog.hs
    instance ToProlog ObjAttr where 
      toProlog (OA_method oa commalist) = toProlog oa ++ "(" ++ toProlog commalist ++ ")"
      toProlog (OA_dots objAttrElems) =
        case asVar objAttrElems of
          (inside, outside, Just asvar) -> outside ++ "(" ++ intercalate "," [inside, asvar] ++ ")"
          (inside, outside, Nothing)    -> outside ++ "(" ++ inside ++ ")"

    asVar :: [ObjAttrElem] -> (String, String, Maybe String)
    asVar objAttrElems =
       let oalist = toProlog <$> objAttrElems
           outside = last oalist
           inside  = head oalist
        in
        if and [ length oalist == 2
               , isUpper . head $ outside
               , isUpper . head $ inside ]
        then (inside, lcfirst outside, Just $ titleCase outside)
        else (inside, lcfirst outside, Nothing)
        where titleCase "" = ""
              titleCase (x:xs) = toTitle x : xs
              lcfirst "" = ""
              lcfirst (x:xs) = toLower x : xs
       

    instance ToProlog ObjAttrElem where 
      toProlog (ObjAttrElemIdent (Ident oaeii)) = oaeii

    instance ToProlog PredExpr where 
      toProlog (PEOA oa)  = toProlog oa
      toProlog (PEAnd exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEOr  exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEME  matchexp)  = toProlog matchexp

    instance ToProlog MatchExpr where
      toProlog (ME_OA_JL oa@(OA_dots oaes) jl) =
        case asVar oaes of
          (inside, outside, Just asvar) -> intercalate ", " [ toProlog oa, "match(" ++ asvar, toProlog jl ++ ")" ]
          (inside, outside, Nothing)    -> "%% not sure what to do here"
      toProlog (ME_OA_JL oa jl) = "%% unable to render a match against a junctionlist because the object-attribute doesn't look like Upper.lower"
      toProlog (ME_True)        = "true"
      toProlog (ME_False)       = "false"

    instance ToProlog JunctionList where
      toProlog (JL_Comma l) = "plain, [" ++ toProlog l ++ "]"
      toProlog (JL_And   l) =   "and, [" ++ toProlog l ++ "]"
      toProlog (JL_Or    l) =    "or, [" ++ toProlog l ++ "]"
      toProlog (JL_Xor   (XorList l)) -- you can take out the plain bit when the xor match in prolog is working properly
        | length l == 1       = "plain, [" ++ toProlog (XorList l) ++ "]"
        | otherwise           =   "xor, [" ++ toProlog (XorList l) ++ "]"

    instance ToProlog CommaList where
      toProlog (CommaList  l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   AndList where toProlog (  AndList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog    OrList where toProlog (   OrList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   XorList where toProlog (  XorList l) = intercalate ", " $ toProlog <$> l

    instance ToProlog CommaElem where
      toProlog (CommaElemObjAttr oa) = toProlog oa
      toProlog (CommaElemString  oa) = show oa
    instance ToProlog   AndElem where
      toProlog (  AndElemObjAttr oa) = toProlog oa
      toProlog (  AndElemString  oa) = show oa
    instance ToProlog    OrElem where
      toProlog (   OrElemObjAttr oa) = toProlog oa
      toProlog (   OrElemString  oa) = show oa
    instance ToProlog   XorElem where
      toProlog (  XorElemObjAttr oa) = toProlog oa
      toProlog (  XorElemString  oa) = show oa

#+end_src

Some helper functions
  #+begin_src prolog :tangle bnfc/prolog/prelude.pl
    % this file is autogenerated! -*- prolog -*-
    % 1. tangle dsl/README.org using C-c C-v C-t
    % 2. run (cat prelude.pl; ./mkProlog test1.l4) > potato.pl

    :- use_module(library(yall)).

    match(Elem, or,  List)   :- member(Elem, List).
    match(Elem, and, List)   :- maplist(  [X]>>myeq(X,Elem), List).
    match(Elem, xor, List)   :- partition([X]>>myeq(X,Elem), List, In, _Out), length(In,L), L = 1.
    match(Elem, plain, List) :- match(Elem, or, List).
    myeq(A,B) :- A == B.
    
    % set up a couple of test potatoes
    species(potato1, "Solanum tuberosum").
    species(potato2, "Ipomoea batatas").

  #+end_src

**** Flora-2

**** Python for DocAssemble

**** Javascript because Javascript is everywhere, like bacteria on your skin



* Underlying Logics and Concepts

We build on a combination of the lamdba, mu, and pi calculi. What would we do without the Greeks?

** Temporals: Time

We need to say things like: from T1 to T2, X was married to Y; from T3 to T4, X was married to Z. (OWL doesn't support this; it's timeless.)

We want [[https://en.wikipedia.org/wiki/Temporal_database][multi-temporality]]: at time T1, party P believed that the legislation then in effect was L1; however, at time T3, party P realized that the legislation in effect at T1 was actually L2, having replaced L1 at time T2. However, L2 made provision that at time T1, the effective result for parties in P's situation would be as if L1 were in effect.

So, we need the usual temporal notions of deadlines, durations, relative and absolute time referents, repeating periods.

- Temporals :: DMN refers to a standard temporal theory of before/overlap/after. We want to reconcile that with the Event and Situation calculi.

#+BEGIN_QUOTE
*Comment MS:* I think there are two issues involved in the above discussion of multi-temporality:
- the question how time evolves during the lifetime of a contract (assuming
  that the rule set remains stable) and which actions are / have to be taken
  at each moment by the parties involved. Formal models for this are Timed
  Automata, Petri Nets etc. These generate / accept a set of traces, and one
  can reason about them with temporal logics (LTL, CTL: "eventually / always",
  "in some / all runs") or their timed variants (TCTL: "some time in the next
  50 time units"). This technology is well understood at least in isolation,
  but maybe not in conjunction with all the other features we need.
- the question how the validity of a rule set changes over time. Seems closely
  related to the question of metarules mentioned below. These seem extremely
  difficult to deal with in full generality. A self-referential rule like
  "This rule will not be valid in a month any more" looks like a variant of
  the Liar's Paradox: Either the rule is still valid in a month (but
  shouldn't be according to what it states), or it is not valid in a month
  (but then there is no rule contradicting its validity, so as a rule
  appearing in a contract, why shouldn't it be valid?). To avoid these
  paradoxes, one would need a stratified set of rules, and a prover would have
  to iterate several times over the rule set to determine the applicable rules.
#+END_QUOTE

#+begin_quote
*Meng's thoughts*: Yes, that makes sense. What software already knows how to reason in this way?
#+end_quote

** Deontics: Obligations, Permissions, and Prohibitions

Meng thinks the whole Chisholm family of paradoxes is only a problem in a framework that doesn't define obligations in terms of breach.

"You gotta do X." "Or what?" "Or nothing." "Then I don't gotta do it, do I?"

So, in Forrester's paradox, if the penalties for each level of murder -- gentle vs bloody -- are explicitly given in a partial order, then the paradox goes away.

#+BEGIN_QUOTE
*Comment MS:* I agree and hope we can do without explicitly using deontic
 logic. A rule R might say: "if condition C is met, you have to do A". If one
 reads this as an /obligation to do/ and not an /obligation to be/, one can
 give it an operational reading: if, in the current state, condition C is
 satisfied and I take action A, then I will get into a state of conformity
 with rule R. If I do not take action A, I will get into a state where I
 breach rule R. Other rules might say that there is a penalty for this breach,
 and I can explicitly reason about the costs: If I am late arriving at the
 airport, is it better to park the car in a non-parking zone and pay a fine or
 to miss the plane?

Question: which kind of obligations do we have: /to do/ or /to be/?
#+END_QUOTE

#+begin_quote
*Meng's thoughts: Right. Let's agree that we aren't going to do traditional SDL.

We borrow some of the useful ideas of deontic logic, e.g. may Y => not must not Y.

But we don't talk about "must be", we only talk about "must do".

People have choice, the way people had choice in the Israeli daycare case: [[https://rady.ucsd.edu/faculty/directory/gneezy/pub/docs/fine.pdf]["A Fine is a Price"]].

The gentle murderer gets 10 years in prison.

The bloody murderer gets 20 years in prison.

No problem.

Hvitved takes this approach; chapter 2 talks about choice.
#+end_quote

** Party

The notion of party is complicated by the notion of "affiliates" and "subsidiaries". Also by the notion of a power of attorney, a trust, and other agent relationships.

Sometimes a master agreement will establish a relationship between one group of companies and another group of companies. So we even get to employ the concept of transitive closure.

See https://youtu.be/b6kkvvHfEOo?t=420 for a simple case of detecting such relations.

** States, Actions, and Events: 

What LegalRuleML calls "maintenance" and "achievement" obligations.

This is an opportunity to use LTL/CTL.

** Definitions and truth values

What LegalRuleML calls "constitutive rules", as opposed to regulative or prescriptive rules. This is one place where we might talk about FOL and a choice of well-founded semantics vs the stable model semantics.

The recent discourse about binary vs nonbinary genders gives a good opportunity to talk about binary vs ternary logics.

** Default logic

See section below on Rules and Metarules.

** Defeasible Logic

Do we really need explicit defeasibility?

** Subjective Perspective:

I want our epistemic theory to be able to express "X thinks Y thinks Z is true."

Or, "Interpretation /I1/ of this text assigns one set of truth values to the following formula; Interpretation /I2/ assigns a different set, and so on."

In 2020 it seems appropriate for a KRR system to admit multiple points of view, rather than to hold to set of global, universal truths. If the parties "agree to disagree", our "artificial intelligence" should not be flummoxed: “The test of a first-rate intelligence,” he said, “is the ability to hold two opposed ideas in the mind, at the same time, and still retain the ability to function.” https://quoteinvestigator.com/2020/01/05/intelligence/

Within the text, a grammar of epistemic modals should handle this.

In the interpreter, we might rely on answer-set-programming or SAT to construct multiple interpretive universes. Ambiguous interpretations of source text could simply show up as branching alternatives.

** Space: "Jurisdiction"

Different countries have different defaults and interpretational conventions.

A clause may be enforceable in one jurisdiction but not in another.

Enforceability is a judgement to be applied late in the compilation process.

** Specificity: Intensionality and Extensionality

- "No party who qualifies under section 12 may ..."

- "Alice Apple, of 1 Address Point, specifically may ..."

So the quantifiers of FOL are relevant here.

** Scope: for the purposes of this section
** Stack: the Call Stack as input to a function

While this is not recommended, some styles of drafting say:

Definition of X:
- for the purposes of P1, X is X1;
- for the purposes of P2, X is X2;
- however, if the use of this variable X causes some Y to be negative, then X shall be the nearest number needed for Y to be non-negative.

This "easier said than done" sentence gets us into constraint programming and linear equations.

What if purpose P1 stacks a hypothetical purpose P2 in its call to X?

We need a meta-rule along the lines of /lex specialis/ which tells us that in such a situation P2 is located closer in the call stack to X than P1.

** Supposing: hypothetical, counterfactual specification with some variable set to other than what it "should be"

The Weekend Dinner price of a dish is 1.5 times what the price of the dish would have been if it were served for Weekday Lunch.

#+begin_example
DEEM              dish.price(weekend=true,  period=dinner) =
     hypothetical(dish.price(weekend=false, period=lunch)) * 1.5
#+end_example

This looks simple enough. Is it really necessary to wrap it in a "hypothetical"? Maybe yes, maybe no.

What if the computation actually depends on a whole bunch of State? In fact, it could get worse -- it could depend on the call stack:

** Natural Language Support

This isn't strictly a logical matter, but if we are to extract (controlled) natural language isomorphisms we will need ways to annotate the L4 syntax with hints. In particular, idioms (in NL) and functions/macros (in L4) are a way of compacting longer expressions into shorter, reusable versions.

** Macros and Functions

"Homoiconicity" refers to the idea that a program may modify itself. Contracts and laws frequently include "pragma" and "macro" type statements intended to influence interpretation.

** <<<Rules and Metarules>>>

If multiple rules ostensibly conflict, that just means they are really only rule fragments, and need to be resolved by composition into a larger coherent rule.

Laws are sometimes written as if the drafters were drunk:

#+begin_example
1. Section 1.
   1. The speed limit is 100.
   2. No person may exceed the speed limit.
   3. Any person who may exceed the speed limit shall pay a fine of $100 for every 10 kph above the speed limit.
   4. The speed limit is 80 when it is raining.
   5. The speed limit may be increased beyond 100 during clear weather in daytime.
   6. Nothing in this section 1 shall allow a speed greater than 120.
#+end_example

Read literally, these rules all contradict each other. They need to be read together in context:

#+begin_src haskell
  type Raining = Bool
  type Daytime = Bool
  speedlimit :: Raining -> Daytime -> Int
  speedlimit False False = 100
  speedlimit False True  = 120
  speedlimit True  _     = 80
#+end_src

Sometimes people talk about "default logic". In conventional programming, defaults go at the end.

#+begin_src python
  def speedlimit (raining, daytime):
      if raining: return 80
      if daytime: return 120
      return             100
#+end_src

In legal drafting, the order is inverted: defaults go at the top; exceptions appear below; exceptions to exceptions appear farther below.

** Explainability

"Show your work: explain to me all the reasons that the outcome was calculated as it was."

The Youtube link above to Coherent Knowledge's Ergo for Financial Regulation demo around Reg W is a good example of what explanation should look like, at least for a datalog-type query.

See also: the New Zealand rates rebates case
https://github.com/smucclaw/complaw/blob/master/doc/ex-nz-rates-20200909/aotearoa-haskell

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/aotearoa-haskell $ stack exec aotearoa-exe -- combined_income=20000 dependants=0 rates_total=2000 additional_per_dependant=500 initial_contribution=160 maximum_allowable=630 income_threshold=25180 --goal=l4/from-openfisca-rr.l4 --nlgstyle=concrete
showing how we obtain the answer
630.00 -- which is
  the greater of
  simply 0.00
  and
  630.00 -- which is
    the lesser of
    1874.67 -- which is
      the difference between
      1840.00 -- which is
        the difference between
        2000.00 -- which is
          rates_total, the rates payable for that rating year in respect of the property
        and
        160.00 -- which is
          initial_contribution, the initial contribution by ratepayer
      and
      -34.67 -- which is
        the sum of
        613.33 -- which is
          the quotient given by
          1840.00 -- which is
            the difference between
            2000.00 -- which is
              rates_total, the rates payable for that rating year in respect of the property
            and
            160.00 -- which is
              initial_contribution, the initial contribution by ratepayer
          divided by
          simply 3.00
        with
        -648.00 -- which is
          $1 for each $8 in
          -5180.00 -- which is
            the difference between
            20000.00 -- which is
              combined_income, the ratepayer's income for the preceding tax year
            and
            25180.00 -- which is
              the sum of
              0.00 -- which is
                the product of
                0.00 -- which is
                  dependants, person who was a dependant of the ratepayer
                multiplied by
                500.00 -- which is
                  additional_per_dependant, the additional allowable income per dependant
              with
              25180.00 -- which is
                income_threshold, the income threshold
    and
    630.00 -- which is
      maximum_allowable, the maximum rebate allowed

#+end_example

See also: argumentation theory.

** Constraints and Inference

Our reasoner should be able to combine backward and forward chaining.

https://cliplab.org/papers/Haemmerle14ppdp.pdf

* Output

#+begin_src bnfc :noweb yes :tangle bnfc/l4.bnfc
<<l4bnfc>>
<<l4expressions>>
#+end_src
