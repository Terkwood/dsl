-- this is auto-generated from README.org. Use C-c C-v C-t to output a fresh version of this file.
Rule.      Rule      ::= "RULE" RuleDef RuleName RuleBody;

RID.       RuleDef   ::=         ObjAttr ;
RNumID.    RuleDef   ::= Integer ObjAttr ;
RNum.      RuleDef   ::= Integer ;
RName.     RuleName  ::= OptLangStrings ;

rules      OptLangStrings ::= | LangStrings;

RBNoop.    RuleBody  ::= "NOOP";
RuleDeem.   RuleBody  ::= GivenLimb "DEFINE" [Constraint] WithLimb WhenLimb WhereLimb;
RModal.  RuleBody    ::= GivenLimb PartyLimb DeonticLimb WhenLimb DeadlineLimb HenceLimb WhereLimb ;
rules    PartyLimb   ::= "PARTY" PartyDef AsAlias;
PSome.   PartyDef    ::= ObjAttr ;
PEvery.  PartyDef    ::= PEvery ;
rules    PEvery      ::=          "EVERYBODY" | "ANYBODY" | "EVERYONE" | "ANYONE" ;
PNobody. PartyDef    ::= PNobody;
rules    PNobody     ::=          "NOBODY" | "NO-ONE" | "NOONE" | "NONE" ;
rules    AsAlias     ::= | "AS" ObjAttr ;
REntity.   Entity ::= "ENTITY" ObjAttr OptLangStrings GivenLimb "ISA" ObjAttr WithLimb Asof WhenLimb WhereLimb;
rules      WhenLimb   ::= | "WHEN"   Exp UnlessExpr;
rules      UnlessExpr ::= | "UNLESS" Exp;
rules    DeonticLimb ::= DeonticExpr ActionLimb;
DEMust.  DeonticExpr ::= "MUST" ;
DEMay.   DeonticExpr ::= "MAY"  ;
DEShant. DeonticExpr ::= "SHANT" ;
rules    ActionLimb  ::= ObjMethod [Blah] AsAlias ;
rules    DeadlineLimb ::= | "BEFORE" TemporalExpr AsAlias ;
rules     TemporalExpr ::= DateTime DurationExpr | ObjAttr DurationExpr
                        | "EARLIEST" LstExp
                        | "LATEST"   LstExp;
rules     DurationExpr ::= | "+" Duration ;
TDY.      Duration     ::= Integer "YEARS" ;
TDM.      Duration     ::= Integer "MONTHS" ;
TDW.      Duration     ::= Integer "WEEKS" ;
TDD.      Duration     ::= Integer "DAYS" ;
TDBD.     Duration     ::= Integer "BUSINESS" "DAYS" ;
TDDH.     Duration     ::= Integer "DAYS" "AND" Integer "HOURS" ;
DNoHence. HenceLimb    ::= ;
DHence.   HenceLimb    ::= "HENCE" Goto Args OptLangStrings;
DHeLe.    HenceLimb    ::= "HENCE" Goto Args OptLangStrings "LEST" Goto Args OptLangStrings ;
DLest.    HenceLimb    ::=                                  "LEST" Goto Args OptLangStrings ;
rules     Goto         ::= RuleDef | "FULFILLED" | "BREACH" ;
rules      GivenLimb ::= | "GIVEN"  GivenExpr ;
rules      GivenExpr ::=   [ObjAttr]
                         | [ObjAttr] HavingLimb ;
rules     HavingLimb ::= "HAVING" "{" [HavingBoolExp] "}";
rules     HavingBoolExp ::= Exp;
separator nonempty HavingBoolExp ";";
rules      WithLimb  ::= | WithHas "{" [WithIn] "}";
rules      WithHas   ::= "WITH" | "HAS" | "TYPE" ;
rules      WithIn    ::= [Constraint] | TraceExpr;
separator nonempty WithIn ";";
Asof.      Asof      ::= "ASOF" DateTime ;
AsofNull.  Asof      ::= ;
rules      DateTime  ::= Iso8601 | "PRESENT" | "NOW" ;
rules      Iso8601   ::= YYYYMMDD | YYYYMMDDTHHMM;

token YYYYMMDD      ( digit digit digit digit '-'? digit digit '-'? digit digit );
token YYYYMMDDTHHMM ( digit digit digit digit '-'? digit digit '-'? digit digit 'T' digit digit digit digit );
rules     WhereLimb ::= | "WHERE" "{" [WhereExp] "}" ;
rules     WhereExp  ::= GivenLimb Constraint WithLimb WhenLimb WhereLimb ;

separator nonempty WhereExp ";";
rules   RuleBody  ::= "MATCHTYPE" "{" [MatchVars] "}";
rules   MatchVars ::= "Constraint"  Constraint
                    | "ObjMethod"   ObjMethod
                    | "ObjAttr"     ObjAttr
                    | "ObjAttrElem" ObjAttrElem
                    | "UnifyExpr"   UnifyExpr
                    | "UnifyElem"   [UnifyElem]
                    | "Exp"         Exp
                    | "LstExp"      LstExp
                    | "BinExp"      BinExp
                    | "CaseExpr"    CaseExpr
                    | "WhenLimb"    WhenLimb
                    | "WhereLimb"   WhereLimb
                    | "DeonticLimb" DeonticLimb
                    | "BraceList"   BraceList
                    | "HenceLimb"   HenceLimb;
separator nonempty MatchVars ";";
RScenario. Scenario ::= "SCENARIO" ObjAttr WithLimb TraceExpr Asof WhereLimb ;
rules      TraceExpr ::= "TRACE" "{" [LogEvent] "}";
rules      LogEvent ::= Iso8601 ObjAttr ObjAttr [Blah] ;
separator  nonempty LogEvent ";";
separator  Blah "";
rules      Blah     ::= Exp;
ModuleDecl. Module ::= "module" ObjAttr "where";
Toplevel.  Tops      ::= [Toplevels];
rules      Toplevels ::= Module | Import | Pragma
                       | Rule | Entity | Scenario ;
terminator Toplevels ";";

layout toplevel;
layout "WITH", "TRACE", "WHERE", "MATCHTYPE", "HAVING", "CASE" ;
entrypoints Tops;
Import. Import ::= "import" ObjAttr ;
rules Pragma ::= "pragma" [Exp] ;
comment "//" ;
comment "--" ;
comment "/*" "*/" ;
coercions Exp 9;
ConstE. Exp8 ::= ConstVal;
CaseE.  Exp7 ::= CaseExpr ;
ListE.  Exp7 ::= LstExp ;
BracesE. Exp7 ::= BraceList ;
TempE.  Exp7 ::= DateTime ;
UnifyE. Exp6 ::= UnifyExpr;
ObjME.   Exp6 ::= ObjMethod ;
Op1E.   Exp5 ::= UnaOp   Exp ;
Op2E.   Exp4 ::=         BinExp ;
Op3E.   Exp3 ::= TriOp   Exp7 Exp7 Exp7; ;
Op3ETern1.  Exp2 ::=         Exp "?"    Exp ":"    Exp;
Op3ETern2.  Exp2 ::=    "IF" Exp "THEN" Exp "ELSE" Exp;

ListComma.  LstExp ::=    "[" [Exp]         "]" ;
ListAnd.    LstExp ::=    "[" [Exp] "&" Exp "]" ;
ListOr.     LstExp ::=    "[" [Exp] "|" Exp "]" ;
separator nonempty Exp "," ;

TriOpITE. TriOp ::= "ITE" ;

BoolV_T. ConstVal ::=  TrueBool ;
BoolV_F. ConstVal ::= FalseBool ;
BoolV_N. ConstVal ::= NothingBl ;
IntV.    ConstVal ::= Integer ;
FloatV.  ConstVal ::= Double ;
StringV. ConstVal ::= String ;
FloatPercent.  ConstVal ::= Double  "%" ;
IntPercent.    ConstVal ::= Integer "%" ;

coercions BinExp 8;
BArith_Pow.  BinExp7   ::= Exp5 "**"   Exp6;
BArith_Mul.  BinExp4   ::= Exp4 "*"    Exp5;
BArith_Div.  BinExp4   ::= Exp4 "/"    Exp5;
BL_In.       BinExp4   ::= Exp4 "IN"   Exp5;
BArith_Plus. BinExp3   ::= Exp4 "+"    Exp5;
BArith_Sub.  BinExp3   ::= Exp4 "-"    Exp5;
L_Join.      BinExp3   ::= Exp4 "++"   Exp5;
BCmp_LT.     BinExp2   ::= Exp4 "<"    Exp5;
BCmp_LTE.    BinExp2   ::= Exp4 "<="   Exp5;
BCmp_GT.     BinExp2   ::= Exp4 ">"    Exp5;
BCmp_GTE.    BinExp2   ::= Exp4 ">="   Exp5;
BCmp_Eq.     BinExp2   ::= Exp4 "=="   Exp5;
BCmp_Neq1.   BinExp2   ::= Exp4 "/="   Exp5;
BCmp_Neq2.   BinExp2   ::= Exp4 "!="   Exp5;
BCmp_Ass1.   BinExp2   ::= Exp4 "="    Exp5;
BCmp_Ass2.   BinExp2   ::= Exp4 ":="   Exp5;
BCmp_Match1. BinExp2   ::= Exp4 "~"    Exp5;
BCmp_Match2. BinExp2   ::= MatchQuantifier Exp6 MatchQualifier MatchRelation
                           MatchQuantifier Exp6 [MatchFlag];
BCmp_NMatch. BinExp2   ::= Exp4 "!~"   Exp5;
BRel_Is.     BinExp1   ::= Exp4 "IS"   Exp5;
BRel_Isa.    BinExp1   ::= Exp4 "ISA"  Exp5;
BRel_Has.    BinExp1   ::= Exp4 "HAS"  Exp5;
BRel_Are.    BinExp1   ::= Exp4 "ARE"  Exp5;
BRel_To.     BinExp1   ::= Exp4 "TO"   Exp5;
BBool_And1.  BinExp    ::= Exp4  "∧"   Exp4;
BBool_And2.  BinExp    ::= Exp4  "&&"  Exp4;
BBool_And3.  BinExp    ::= Exp4  "AND" Exp4;

BBool_Or1.   BinExp    ::= Exp  "∨"   Exp;
BBool_Or2.   BinExp    ::= Exp  "||"  Exp;
BBool_Or3.   BinExp    ::= Exp  "OR"  Exp;

Set_Union.      BinExp ::= Exp  "∪"   Exp;
Set_Intersect.  BinExp ::= Exp  "∩"   Exp;
Set_Subset.     BinExp ::= Exp  "⊂"   Exp;

L_Union.        BinExp ::= Exp "UNION"     Exp ;
L_Intersect.    BinExp ::= Exp "INTERSECT" Exp ;

-- ConstVal here will probably need to be upgraded to at least a variable
-- so we can say, TheRelevantQuorum.Percentage
MQSat0.      MatchQuantifier ::= "NONE OF" ;
MQSatMin.    MatchQuantifier ::= "AT" "LEAST" ConstVal "OF" ;
MQSatAny.    MatchQuantifier ::= "ANY" "OF" ;
MQSatAll.    MatchQuantifier ::= "ALL" "OF" ;
MQSatConst.  MatchQuantifier ::= "EXACTLY" ConstVal "OF" ;
MQSatMax.    MatchQuantifier ::= "AT" "MOST" ConstVal "OF" ;
MRelSat1.    MatchRelation   ::= "SATISFIES" ;
MRelSat2.    MatchRelation   ::= "SATISFY" ;
MRelMatch1.  MatchRelation   ::= "MATCHES" ;
MRelMatch2.  MatchRelation   ::= "MATCH" ;
MRelIs1.     MatchRelation   ::= "IS" ;
MRelIs2.     MatchRelation   ::= "ARE" ;

MQualEach.      MatchQualifier ::= "EACH";
MQualTogether.  MatchQualifier ::= "TOGETHER";
MQualJS.        MatchQualifier ::= "JOINTLY-AND-SEVERALLY";
MQualNull.      MatchQualifier ::= ;

MFlagLDistinct. MatchFlag     ::= "L-DISTINCT" ;
MFlagRDistinct. MatchFlag     ::= "R-DISTINCT" ;
MFlagBDistinct. MatchFlag     ::=   "DISTINCT" ;
MFlagNoRepeat.  MatchFlag     ::= "NO-REPEATS" ;
separator MatchFlag ",";

coercions UnaOp 7;
UCurr.       UnaOp7 ::= CurrencyPrefix ;
CurrCode.     CurrencyPrefix ::= ":" UIdent ":" ;
CurrDollar.   CurrencyPrefix ::= "$";

UBool_Not1.  UnaOp6 ::= "!"  ;
UBool_Not2.  UnaOp6 ::= "NOT" ;
UBool_Not2.  UnaOp6 ::= "¬" ;
UBool_Unlikely.  UnaOp5 ::= "UNLIKELY" ;
UBool_Likely.    UnaOp5 ::= "LIKELY" ;

L_All.       UnaOp5 ::= "ALL";
L_Any.       UnaOp5 ::= "ANY";
L_Xor.       UnaOp5 ::= "XOR";

token TrueBool  ["Tt"] ["Rr"] ["Uu"] ["Ee"] ;
token FalseBool ["Ff"] ["Aa"] ["Ll"] ["Ss"] ["Ee"];
token NothingBl ["Nn"] ["Oo"] ["Tt"] ["Hh"] ["Ii"] ["Nn"] ["Gg"] ;

rules      ObjAttrElem  ::= Ident | UIdent ;            -- Foo

OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
separator nonempty ObjAttrElem ".";
separator nonempty ObjAttr     ",";
rules      ObjMethod  ::= [UnifyElem] Args ;
rules      Args       ::= | "(" [Constraint] ")";
rules      UnifyExpr ::= [UnifyElem] ;
rules      UnifyElem ::= ObjAttrElem
                      |  UnifyBracket
                      |  UnifyStar
                      |  "."; -- ideally we would have foo..bar and not foo...bar
separator nonempty UnifyElem ".";
rules      UnifyStar ::= "*" ;
rules      UnifyBracket ::= "<" [CommaElem] ">" ;
rules      CommaElem ::= ObjAttr;
separator nonempty CommaElem ",";
rules BraceList     ::= "{" [Constraint] "}" ;
rules  Constraint   ::= Exp;
separator nonempty Constraint  "," ;

-- rules ConstraintBinOp ::= "=" | "<" | ">" | "<=" | ">=" | "==" | "IS" | "ISA" | "ARE" | "HAS";
rules CaseExpr  ::= "CASE" "{" [CaseExp] "}" ;
rules CaseExp   ::= Exp "->" Exp;
separator nonempty CaseExp ";";
TU.        TypeUnify      ::= "::" "Unify";
TS.        TypeString     ::= "::" "STRING";
TB.        TypeBool       ::= "::" "Bool";
TM.        TypeMath       ::= "::" "Math";
TOM.       TypeObjMethod  ::= "::" "ObjMethod";
TT.        TypeTemporal   ::= "::" "Temporal";
token UIdent (upper (letter | digit | '_')*) ; -- doesn't seem to work for single character idents though, like P
rules      UIdentList ::= [UIdentElem];
rules      UIdentElem ::= UIdent;
separator nonempty UIdentElem ".";

ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= LangID String ;
rules         LangID       ::= ":" [LangLabel] ":";
rules         LangLabel    ::= Ident ;
    separator nonempty LangLabel "," ;
