#+TITLE: Synchronizing L4 Contracts

L4's contract semantics belong to the family of process calculi e.g. CSP and Petri Nets.

How do we synchronize actions and events in L4?

* Example: Multistage Paperwork.

1. First Trial
   - Party A may submit the application fee and the application form together to Party B.

2. Second Trial
   - Party B must forward Party A's submission to Party C, within 1 day.
   - Party B must file a copy with the Permanent Archive.

3. Third Trial
   - Party C must do one of these things within 3 days:
     1. accept the submission.
     2. reject the submission without explanation.
     3. return the submission with amendments to Party A.

* Possible Representations

Let's explore a few standard representations of the above process.

** As A Petri Net, without time

First we model the system as an untimed Petri Net. The diagram below shows a starting state, where Party A has prepared both the fee and the form, and is about to submit them.

[[./anim1.gif]]

#+begin_src graphviz-dot :tangle untimed-petri.dot
  digraph G {
    subgraph place {
      graph [shape=circle,color=gray];
      node [shape=circle,fixedsize=true,width=1.5];
      a_form   [label="A:\napplication\nform\n\n"];
      a_fee    [label="A:\napplication\nfee\n\n"];
      b_review [label="B:\ngatekeeper\n\n"];
      c_in     [label="C:\napplication\nreceived\n\n"];
      c_out1   [label="C:\naccepted\n\n\n"];
      c_out2   [label="C:\nrejected\nwithout\nexplanation\n\n"];
      c_out3   [label="C:\nrejected\nwith\namendments\n\n"];
      pa       [label="\nPermanent\nArchive\n\n"];
    }
    subgraph transitions {
      node [shape=rect,height=0.2,style=filled,fillcolor=black,fontcolor=white,fontname=Monaco];
      submission   [label="submit"];
      transmission [label="receive"];
      return       [label="return to applicant"];
      c_review1 [label="accept"];
      c_review2 [label="reject"];
      c_review3 [label="resubmit"];
    }

    subgraph cluster_inputs {
      graph [style=invis];
      a_form;
      a_fee ;
    }

    { a_form a_fee } -> submission -> b_review -> transmission;
    transmission -> { pa c_in };

    subgraph cluster_review {
      graph [label="decision", labeljust="l"];
      node [shape=rect,height=0.2,style=filled,fillcolor=black,fontcolor=white,fontname=Monaco];
      c_review1;
      c_review2;
      c_review3;
    }

    c_in -> { c_review1 c_review2 c_review3 } ;

    subgraph cluster_outputs {
      graph [style=invis];
      c_review1 -> c_out1;
      c_review2 -> c_out2;
      c_review3 -> c_out3 -> return -> a_form;
    }
  }

#+end_src

** As a Petri Net, with time

Timed Petri Nets augment standard Petri Nets with a time window on each transition.

* Representation in L4

We could represent the process in L4 as follows:

#+begin_src haskell
  RULE    SendFee
    PARTY A
      MAY send fee to B

  RULE    SendForm
    PARTY A
      MAY send form to B

  RULE    Receive
     UPON [ SendFee & SendForm ]
    PARTY B
     MUST [ send application to C AS Transmission
          & send application to PermanentArchive ]
   BEFORE + 1 DAYS

  RULE    Decide
     UPON Transmission -- could also be UPON Receive
    PARTY C
     MUST [ accept
          , reject(explanation=no)
          | return(explanation=yes) to A AS Return
          ]
   BEFORE Receipt + 3 DAYS
#+end_src

** Alternative Representations

#+begin_src haskell
  RULE    TwoEnvelopes
    PARTY A
      MAY [ send fee
          & send form ] to B AS Submission
#+end_src

#+begin_src haskell
  RULE    OneEnvelope
    PARTY A
      MAY send [ fee
               & form ] to B AS Submission
#+end_src

* Translation from L4 to Standard Representations

* Infrastructure

** Prerequisites

- Imagemagick's ~convert~

** mkMultiPetri

A little Haskell script to transform the primary Dot file representation into a bunch of animated PNGs. See also [[./Makefile]]

#+begin_src haskell :tangle mkMultiPetri.hs
  #!/usr/bin/env stack
  -- stack --resolver lts-16.20 script --package split 
  {-# LANGUAGE Haskell2010 #-}
  -- stack ./mkMultiPetri.hs < untimed-petri.dot
  -- convert a single untimed-petri dot file to frames of an animation
  -- "you can write FORTRAN^H^H^H^H^H^H^HPerl in any language"

  import Control.Monad (forM_)
  import Data.List.Split
  import System.Environment

  main = do
    inlines <- lines <$> getContents
    forM_ [ ("anim1", "a_form a_fee > b_review > c_in pa > pa c_out1")
          , ("anim2", "a_form a_fee > b_review > c_in pa > pa c_out2")
          , ("anim3", "a_form a_fee > b_review > c_in pa > pa c_out3 > pa a_form") ] (
      \(outfile, tokenSpecs) -> do
        forM_ (zip [1..] (splitOn " > " tokenSpecs)) (
          \(frameN,actives) ->
            writeFile (outfile++"-"++(show frameN)++".dot") $ unlines $
            (flip map) inlines (
            \inline -> let ws  = words  inline
                           len = length inline
                           insert str = take (len - 3) inline ++ str ++ drop (len - 3) inline
                       in if        "\\n\\n\"];" == (drop (len - 7) inline)
                          then if   length ws > 0 && head ws `elem` (words actives)
                               then insert "&bull;"
                               else insert "\\n"
                          else id inline

            )
          )
      )
#+end_src

** gitattributes

https://medium.com/@clarkbw/managing-generated-files-in-github-1f1989c09dfd
